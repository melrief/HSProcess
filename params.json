{"name":"Hsprocess","tagline":"Haskell Stream Processor for the command line","body":"# Haskell Stream Processor\r\n\r\nHaskell Stream Processor is a command line utility to process streams\r\nusing [Haskell](http://www.haskell.org) code.\r\n\r\nThere are many reasons why Haskell is suitable for stream processing from the\r\ncommand line.  Code written in Haskell is concise thanks to a clean syntax and\r\nthe type inference which allows code without type decoration. Also it is very\r\neasy to define one-line transformations by combining functions.\r\n\r\nFor example:\r\n\r\n```sh\r\nhsp \"L.map (L.head . words) . lines\"\r\n```\r\n\r\nprints the first word of each line of the input stream.\r\n\r\n## Installation\r\n\r\nFrom the project directory\r\n\r\n```sh\r\ncabal install\r\n```\r\n\r\nThis will compile and install the executable `hsp` and the library\r\n`HSProcess.Representable`.\r\n\r\n##  Usage\r\n\r\n`hsp` supports different modes:\r\n\r\n### Evaluate an expression\r\n\r\nIt is possible to use `hsp` to evaluate a user expression without\r\ninput using the option `-e`:\r\n\r\n```sh\r\nhsp -e \"1\"\r\n```\r\n\r\n### Work on the stream\r\n\r\nThe standard mode of `hsp` process the whole stream. It accepts a\r\nstring representing a transformation from the stream, that has type\r\n`Data.ByteString.Lazy.ByteString`, to some value with type that is an\r\ninstance of `Rows`:\r\n\r\n```haskell\r\nByteString -> Rows a\r\n```\r\n\r\n`Rows` is a special case of `Show` for representing data on the\r\ncommand line . For example, to print on stdout what it gets from stdin:\r\n\r\n```sh\r\nhsp \"id\"\r\n```\r\n\r\n### Split stream in chunks and process them\r\n\r\nMany times, stream processing is about splitting the stream on some delimiter,\r\nlike `'\\n'`, and process each chunk of data. With the standard mode of\r\n`hsp` this can be achieved using the `split` function of `ByteString`:\r\n\r\n```sh\r\nhsp \"L.filter (not . null) . split '\\n'\"\r\n```\r\n\r\nThis happens so often that `hsp` has a mode to split automatically the\r\nstream on a delimiter using `-d [<delimiter>]`.  If\r\n`<delimiter>` is omitted, then it is set to `\\n`. With `-d`, the\r\nfunction provided must have type:\r\n\r\n```haskell\r\n[ByteString] -> Rows a\r\n```\r\nThe command before can be rewritten as:\r\n\r\n```sh\r\nhsp -d \"L.filter (not . null)\"\r\n```\r\n\r\n### Map a function on each chunk of data\r\n\r\nA specific case of `hsp -d <delimiter>` is `hsp -d <delimiter> -m` that\r\nis equivalent of mapping the supplied function to the input list. In this case\r\nthe function must have type:\r\n\r\n```haskell\r\nByteString -> Row a\r\n```\r\n\r\nFor example, to take the first word of each line:\r\n\r\n```sh\r\nhsp -m \"L.head . words\"\r\n```\r\n\r\nWhen `-m` is specified, `-d` can be omitted and the delimiter is\r\nautomatically set to `\\n`.\r\n\r\n## Configuration\r\n\r\nHaskell Stream Processor is a command line utility and for this reason it needs\r\ninformations, like which modules should be loaded, that cannot be easily passed\r\nas arguments. There are two configuration files located under\r\n`$HOME/.hsp`,  one to import modules and one to import user defined\r\nfunctions.\r\n\r\n### Modules\r\n\r\nHaskell Stream Processor reads a list of modules to load from the file\r\n`$HOME/.hsp/modules`. Each line of this file is composed by the name of a\r\nmodule eventually followed by a space and it's qualified name. An example could\r\nbe:\r\n\r\n```sh\r\nControl.Monad\r\nData.List L\r\n```\r\n\r\nwhich means that all the functions from `Control.Monad` and `Data.List`\r\nwill be available to the user, but for `Data.List` functions you must\r\nqualify them with `L.`.\r\n\r\nThere are some modules that are loaded automatically without qualification. In particular,\r\nthe module `Data.ByteString.Lazy.Char8` is automatically loaded\r\nbecause `hsp` works on lazy bytestrings. This means functions like that\r\nin `Prelude` work on list, like `map`, in `hsp` work on\r\n`ByteStrings`. Same for function that work on `String`.\r\n\r\nNote that `Prelude` is loaded with the qualified name `P`, so its\r\nfunctions are not directly visible.\r\n\r\nAn example of module file can be found [in the example directory](https://github.com/melrief/HSProcess/blob/master/examples/modules/modules).\r\n\r\n### User defined functions\r\n\r\nIt is possible to define new function to be used in Haskell Stream Processor\r\ninside the file `$HOME/.hsp/toolkit.hs`.\r\n\r\nAn example of toolkit can be found [in the example directory](https://github.com/melrief/HSProcess/blob/master/examples/toolkit/toolkit.hs).\r\n\r\n## Differences with the Glasgow Haskell Compiler\r\n\r\nIt is already possible to evaluate an function using the\r\n[Glasgow Haskell Compiler](http://www.haskell.org/ghc/) using the option\r\n`-e` and by passing the custom function to `interact`:\r\n\r\n```sh\r\nghc -e \"interact id\"\r\n```\r\n\r\nThe main differences are that Haskell Stream Processor works on (lazy)\r\n`ByteString` instead of the slower `String`, it can load modules\r\nautomatically from the `module` file and can load user defined functions\r\nfrom the `toolkit.hs` file. Also, Haskell Stream Processor supports\r\ndifferent modes from working on the entire stream, like working on each line.\r\n\r\n## Examples\r\n\r\nIn all the examples, `Data.ByteString` is loaded without qualification\r\nwhereas `Data.List` is qualified as `L`. The function `match` is an\r\nalias for `Text.Regex.Posix.=~`.\r\n\r\nEvaluate `2^100`:\r\n\r\n```sh\r\nhsp -e \"2^100\"\r\n```\r\n\r\nPrint numbers from 1 to 100:\r\n\r\n```sh\r\nhsp -e \"[1 .. 100]\"\r\n```\r\n\r\nTake the first line of a stream:\r\n\r\n```sh\r\n... | hsp -d \"L.take 1\"\r\n```\r\n\r\nTake the last two lines of a stream:\r\n\r\n```sh\r\n... | hsp -d \"L.reverse . L.take 2 . L.reverse\"\r\n```\r\n\r\nPrint the 10th element of each line:\r\n\r\n```sh\r\n... | hsp -m \"(L.!! 10) . words\"\r\n```\r\n\r\nPrint the elements from the 2nd to the 20th of each line:\r\n\r\n```sh\r\n... | hsp -m \"L.take 20 . L.drop 1 . words\"\r\n```\r\n\r\nGet the number of words:\r\n\r\n```sh\r\n... | hsp -d \"L.length . L.concatMap words\"\r\n```\r\n\r\nGet the number of lines:\r\n\r\n```sh\r\n... | hsp -d \"L.length\"\r\n```\r\n\r\nSort integers and remove duplicates:\r\n\r\n```sh\r\n... | hsp -d \"L.nub . L.sort . L.map asInt\"\r\n```\r\n\r\nSum the 2nd elements of every line:\r\n\r\n```sh\r\n... | hsp -d \"P.sum . L.map (asFloat . (L.!! 1) . words)\"\r\n```\r\n\r\nSplit each line on a delimiter ':' and print the second element:\r\n\r\n```sh\r\n... | hsp -m \"(L.!! 1) . split ':'\"\r\n```\r\n\r\nRemove empty lines:\r\n\r\n```sh\r\n... | hsp -d \"L.filter (not . null)\"\r\n```\r\n\r\nFilter lines that match a pattern:\r\n\r\n```sh\r\n... | hsp -d \"L.filter (`match` \"t\\\\w\\\\wt\")\"\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}